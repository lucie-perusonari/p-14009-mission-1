# 개요

- 명령 커맨드를 이용해서 작동하는 앱을 만드는 것이 목표.
  - 이를 위해서 지속해서 **입력**을 받아야 함.
- 여기에는 '종료, 등록, 수정, 삭제, 목록' 등등의 기능이 포함됨. => CRUD
  - 주요 구현 대상은 명언(WiseSaying)임.

# 커맨드

- while문을 사용한다.
  - Scanner로 지속적으로 입력을 받는다.
  - "종료"를 입력받기 전에는 입력은 멈추지 않는다.
  - 받은 '커맨드'에 따라서 다르게 동작한다. => 만일 존재하지 않는 커맨드라면 패스한다.

## 스캐너

- <https://stackoverflow.com/questions/26446599/how-to-use-java-util-scanner-to-correctly-read-user-input-from-system-in-and-act> 를 참고함.
- **반복문을 제어할 때에는 switch case 보다는 if문이 편함.**
- 스캐너의 블록킹 기준이 뭔지 모르겠음.
  - 버퍼가 비어있어야지 스캐너가 입력을 받는데, Next와 NextLine의 차이 때문에 블록킹이 제대로 되지 않을 수 있음.
  - **Next는 줄 바꿈을 반환하지 않음. 그래서 다음 번에 NextLine을 사용하면 줄 바꿈을 반환해버림.**
    - => 따라서 **Next 혹은 NextLine만 사용해야함.** 이는 규칙이므로 래퍼 클래스를 만드는 게 나은 듯.

# 종료

- "종료"를 입력 받으면 종료한다.
  - while문을 break한다.

# 등록

- "등록"을 입력 받으면 실행한다.
- 명언(wiseSaying) 및 작가(writer) 정보를 입력 받은 후 등록한다.
  - 명언 및 작가의 정보를 받기 위해. **입출력이** 필요하다.
  - 명언 번호는 순차적으로 증가한다.

# 목록

- "목록"을 입력 받으면 실행한다.
- 명언 객체의 번호, 작가, 명언을 출력한다.
  - 이 때 번호는 내림차순으로 나와야한다.
    - Stack과 유사한데, 이를 어떻게 구현할까?
    - 키 관리가 편한 TreeMap을 사용하기로 함.

# 삭제

- "삭제"를 입력 받으면 실행한다.
- 명언 번호를 받기 위한 입출력이 필요하다.
- 입력받은 명언 번호에 해당하는 명언을 삭제한다.
  - 이후 명언 번호에 대응하는 삭제 메시지를 출력한다.
  - 존재하지 않는 명언 번호인 경우에는 번호에 대응하는 메시지를 출력한다.

# 수정

- "수정"을 입력 받으면 실행한다.
- 명언 번호를 받기 위한 입출력이 필요하다.
- 입력받은 명언 번호에 해당하는 명언을 수정한다.
  - 명언과 작가에 대한 수정 정보를 받기 위한 입출력이 필요하다.
- 처리 결과는 출력하지 않는다.

# 기능 및 설계

## 커맨드

- 커맨드를 입력받을 수 있는 커맨드 라인이 필요하다.
  - => 이는 while문과 Scanner를 사용하며 문자열로 처리한다.
- 커맨드를 실행하는 커맨더가 필요하다.
  - => 커맨드 라인에서 입력 받은 문자열을 switch case문으로 처리한다. 해당하지 않는 문자열은 무시한다.
- => 커맨드 라인과 커맨더는 하나로 처리해도 된다. **커맨드** 객체가 입출력을 책임진다.

### 추가 사항

## 러너

- 커맨드를 처리하는 **러너가** 필요하다.
  - => 러너에서 CRUD에 필요한 입출력을 처리한다.
- 러너는 static 메소드로 커맨드를 처리한다.
  - 러너는 여러 개의 인스턴스가 필요하지 않다.
- 처리 결과는 러너에서 출력한다.
  - 명령에 대한 답으로 해석함.

### CRUD

## 스토어

- 명언 데이터를 저장하는 **스토어가** 필요하다.
- 스토어는 static 메소드로 CRUD를 처리한다.
  - 스토어는 여러 개의 인스턴스가 필요하지 않다.
- 데이터를 저장하기 위한 WiseSaying **객체가** 필요하다.
  - 명언 번호, 명언, 작가를 필드로 지닌다.
  - => **WiseSaying 객체**를 만든다.

### 자료구조

- 여러 개의 WiseSaying을 저장, 수정, 삭제하기 위한 **자료구조가** 필요하다.
  - 내림차순으로 출력하기 편하고, 번호를 통해서 조회하기 편한 자료구조이면 좋겠다.
  - `OrderedMap<int, WiseSaying>` 에 내림차순 정렬을 적용하면 어떨까?
    - 어쩌면 번호의 증가와 입출력 처리를 한꺼번에 해결할 수 있을지 모른다.
    - 단, 번호를 재사용해서는 안 된다.
- 순차적으로 증가하는 번호를 관리해야한다.

# 테스트

- 이렇게 설계하는 건 좋은데, 어떻게 테스트 해야하지?
  - 커맨더, 러너, 스토어 순으로 검증하면 될까?
- 테스트를 하는 과정에서 메소드의 접근 지정자를 수정해야 하는 문제가 있음.
  - 가장 단순한 방법은 접근 지정자를 강제로 public으로 수정하는 방법임.
    - 하지만 이 방법은 private나 default여야하는 메소드들을 검증하는데 한계가 있음.
    - => **이건 테스트 패키지와 메인 패키지를 통일 시켜서 사용하는 것으로 함.**
- 테스트에 사용되는 io가 콘솔이라서 코드만으로는 접근이 어려움.
  - 그렇다면 테스트에 io를 명시해서 사용하는 것으로 함.
  - `System.in`, `System.out`으로 간단하게 처리할 수 있는 듯?
  - System.console.reader를 쓰면 테스트가 안 됨. JVM이 없어서 콘솔도 생성되지 않음.
    - 따라서 테스트에 부적합함.

# 메모

- 구현하다 마는 경우에 TODO를 사용하면 좋을 듯.
- 러너와 스토어의 관계를 설정해야 함. 현재는 연관 관계로 볼 수 있을까?
  - 연관 관계라면 스토어에게 입출력의 책임이 돌아감.
  - 의존 관계라면 러너에게 입출력의 책임이 돌아감.
    - 아마 의존 관계가 나중에 확장에 있어서는 유리할 것임.
    - => 그러나 여기서는 역할의 분리에만 집중해서 연관 관계로 사용하자. 나중에 의존 관계로 구현하면 됨.

- 빌드를 2번 실행하면 `"org.eclipse.core.resources”` 에서 문제가 발생해 빌드가 실패.
  - 최신 버전에서 발생하는 버그인 듯함.
  - <https://github.com/eclipse-jdtls/eclipse.jdt.ls/issues/3401>
